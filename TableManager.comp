/*******************************************************************************
* McStas component: TableManager
*
* %I
* Written by: Contributors to the mcstas-time-of-flight-table project
* Date: 2026
* Origin: ESS
*
* Manages a time-of-flight lookup table built from neutron ray time recordings.
*
* %D
* This component builds and outputs a time-of-flight lookup table by collecting
* the per-neutron time values recorded at each TableRecorder position along the
* beamline.
*
* It inserts a pointer (tof_t) and size integer (tof_n) into every neutron ray's
* state via the McCode USERVARS mechanism.  The component-level USERVARS receive
* an instance-index suffix in the generated C code (e.g. tof_t_5, tof_n_5 when
* this component is the 5th in the instrument); TableManager therefore computes
* the byte offsets to these fields at INITIALIZE time and stores them in
* shared globals so that TableSetup and TableRecorder can access the same
* per-particle storage without knowing the suffix at authoring time.
*
* Placement:
*   TableManager should be placed AFTER the last TableRecorder in the instrument.
*   TableSetup should be placed BEFORE all TableRecorders.
*
* Output file format:
*   Space-separated columns, one row per detected neutron.
*   Columns:  t[0]  t[1]  ...  t[n_recorders-1]  weight
*   A header line beginning with '#' describes the columns.
*
* %P
* INPUT PARAMETERS:
* filename [str]    Name of the output file.  Default: "tof_table.dat"
* max_events [int]  Maximum number of neutron events to record.  Default: 1000000
*
* %E
*******************************************************************************/

DEFINE COMPONENT TableManager

SETTING PARAMETERS (string filename="tof_table.dat", int max_events=1000000)

SHARE
%{
#ifndef _TOF_TABLE_SHARED
#define _TOF_TABLE_SHARED

/* Forward declaration of the particle-variable accessor generated by mccode-antlr.
 * The definition appears later in the same translation unit (visit_macros section),
 * so a forward declaration is sufficient for calling it from INITIALIZE. */
extern void* _get_particle_var(char *token, _class_particle *p);

/* Byte offsets from the start of _class_particle to the tof_t / tof_n fields.
 * Set by TableManager INITIALIZE; used by all three component types in TRACE. */
static ptrdiff_t _tof_t_offset = -1;
static ptrdiff_t _tof_n_offset = -1;

/* Running count of TableRecorder instances, incremented by each one in INITIALIZE. */
static int _tof_recorder_count = 0;

/* Convenience macros: dereference tof_t / tof_n for a given particle pointer.
 * Only valid after TableManager INITIALIZE has set the offsets. */
#define _TOF_T_PTR(particle) (*(double**)((char*)(particle) + _tof_t_offset))
#define _TOF_N_PTR(particle) (*(int*)  ((char*)(particle) + _tof_n_offset))

#endif /* _TOF_TABLE_SHARED */
%}

USERVARS
%{
  /* Per-particle dynamic array of recorded times and its allocated size.
   * These fields are inserted into every neutron ray's state struct.
   * NOTE: the generated C code appends an instance-index suffix, e.g. tof_t_5.
   *       TableManager's INITIALIZE locates those fields by name and stores
   *       their byte offsets so that TableSetup and TableRecorder can use
   *       the _TOF_T_PTR / _TOF_N_PTR macros to access the same storage. */
  double* tof_t;
  int tof_n;
%}

DECLARE
%{
  double* _table_data;      /* flat 2D buffer: row = event, cols = [t[0]..t[n-1], weight] */
  int     _table_n_recorders;
  long    _table_n_events;
  long    _table_max_events;
%}

INITIALIZE
%{
  /* Locate the per-particle USERVARS for this component instance.
   * mccode-antlr names them  tof_t_<index>  and  tof_n_<index>  where
   * <index> == INDEX_CURRENT_COMP (the 1-based position of this component). */
  {
    _class_particle _dummy;
    memset(&_dummy, 0, sizeof(_class_particle));
    char _fname[64];

    snprintf(_fname, sizeof(_fname), "tof_t_%d", INDEX_CURRENT_COMP);
    void* _tp = _get_particle_var(_fname, &_dummy);
    if (!_tp) {
      fprintf(stderr,
        "TableManager ERROR: USERVAR '%s' not found in _class_particle.\n"
        "  Check that this TableManager instance is correctly placed and that\n"
        "  no other component has already defined tof_t / tof_n USERVARS.\n",
        _fname);
      exit(1);
    }
    _tof_t_offset = (char*)_tp - (char*)&_dummy;

    snprintf(_fname, sizeof(_fname), "tof_n_%d", INDEX_CURRENT_COMP);
    void* _np = _get_particle_var(_fname, &_dummy);
    if (!_np) {
      fprintf(stderr, "TableManager ERROR: USERVAR '%s' not found.\n", _fname);
      exit(1);
    }
    _tof_n_offset = (char*)_np - (char*)&_dummy;
  }

  _table_n_recorders = _tof_recorder_count;
  _table_max_events  = max_events;
  _table_n_events    = 0;

  if (_table_n_recorders <= 0) {
    fprintf(stderr,
      "TableManager WARNING: No TableRecorder components found "
      "(or none were initialised before TableManager).\n");
    _table_data = NULL;
  } else {
    /* Allocate: n_recorders time columns + 1 weight column, per event */
    _table_data = (double*)calloc(
      (long)_table_max_events * (_table_n_recorders + 1), sizeof(double));
    if (!_table_data) {
      fprintf(stderr, "TableManager ERROR: Failed to allocate output table.\n");
      exit(1);
    }
  }
%}

TRACE
%{
  if (_tof_t_offset >= 0 && _tof_n_offset >= 0) {
    double* _tof_arr = _TOF_T_PTR(_particle);
    int     _tof_n  = _TOF_N_PTR(_particle);

    if (_table_data && _tof_arr && _tof_n > 0) {
      #pragma omp critical
      {
        if (_table_n_events < _table_max_events) {
          long _base = _table_n_events * (_table_n_recorders + 1);
          int  _nc   = _tof_n < _table_n_recorders ? _tof_n : _table_n_recorders;
          int  _i;
          for (_i = 0; _i < _nc; _i++) {
            _table_data[_base + _i] = _tof_arr[_i];
          }
          _table_data[_base + _table_n_recorders] = p;
          _table_n_events++;
        }
      }
    }

    /* Deallocate per-particle array and reset counter.
     * Use _tof_n > 0 (not _tof_arr) as the guard: tof_n is zero-initialised
     * by particle_uservar_init so a non-zero value guarantees TableSetup ran
     * and that tof_t is either NULL (calloc failed â†’ already ABSORBed) or a
     * valid pointer.  Checking _tof_arr alone would risk freeing uninitialised
     * garbage if a particle somehow skipped TableSetup. */
    if (_tof_n > 0) {
      if (_tof_arr) {
        free(_tof_arr);
        _TOF_T_PTR(_particle) = NULL;
      }
    }
    _TOF_N_PTR(_particle) = 0;
  }
%}

SAVE
%{
  if (_table_data && _table_n_events > 0 && _table_n_recorders > 0) {
    FILE* _f = fopen(filename, "w");
    if (_f) {
      int _j;
      fprintf(_f, "#");
      for (_j = 0; _j < _table_n_recorders; _j++)
        fprintf(_f, " t[%d]", _j);
      fprintf(_f, " weight\n");

      long _i;
      for (_i = 0; _i < _table_n_events; _i++) {
        long _base = _i * (_table_n_recorders + 1);
        for (_j = 0; _j <= _table_n_recorders; _j++) {
          if (_j > 0) fprintf(_f, " ");
          fprintf(_f, "%.15g", _table_data[_base + _j]);
        }
        fprintf(_f, "\n");
      }
      fclose(_f);
    } else {
      fprintf(stderr, "TableManager WARNING: Could not open '%s' for writing.\n", filename);
    }
  }
%}

FINALLY
%{
  if (_table_data) {
    free(_table_data);
    _table_data = NULL;
  }
%}

END
