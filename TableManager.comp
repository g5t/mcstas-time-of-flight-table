/*******************************************************************************
* McStas component: TableManager
*
* %I
* Written by: Contributors to the mcstas-time-of-flight-table project
* Date: 2026
* Origin: ESS
*
* Manages a time-of-flight lookup table built from neutron ray time recordings.
*
* %D
* This component builds and outputs a time-of-flight lookup table by collecting
* the per-neutron time values recorded at each TableRecorder position along the
* beamline.
*
* It inserts a pointer (tof_t) and size integer (tof_n) into every neutron ray's
* state via the McCode USERVARS mechanism.  The component-level USERVARS receive
* an instance-index suffix in the generated C code (e.g. tof_t_5, tof_n_5 when
* this component is the 5th in the instrument); TableManager therefore computes
* the byte offsets to these fields at INITIALIZE time and stores them in
* shared globals so that TableSetup and TableRecorder can access the same
* per-particle storage without knowing the suffix at authoring time.
*
* Placement:
*   TableManager should be placed AFTER the last TableRecorder in the instrument.
*   TableSetup should be placed BEFORE all TableRecorders.
*
* Output file format:
*   Space-separated columns, one row per detected neutron.
*   Columns:  t[0]  t[1]  ...  t[n_recorders-1]  weight
*   A header line beginning with '#' describes the columns.
*
* %P
* filename: string, Name of the output file. Default: "tof_table.dat"
* write_file: int, Whether to write the output file at the end of the simulation. Default: 1 (true)
* t_min: double, Minimum time value for binning. Default: 0
* t_max: double, Maximum time value for binning. Default: 0
* t_bins: int, Number of time bins for the output table. Default: 0 (no binning)
*
* %E
*******************************************************************************/

DEFINE COMPONENT TableManager

SETTING PARAMETERS (
  string filename=0, 
  int write_file=1,
  t_min=0, 
  t_max=0, 
  int t_bins=0
)

SHARE
%{
#ifndef _TOF_TABLE_SHARED
#define _TOF_TABLE_SHARED

/* Running count of TableRecorder instances, incremented by each one in INITIALIZE. */
static int _tof_recorder_count = 0;

#endif /* _TOF_TABLE_SHARED */

int table_manager_array_line_double(FILE * f, double * x, int n){
  fprintf(f, "[");
  for (int i=0; i < n; ++i) {
    if (fprintf(f, "%.15g", x[i]) < 0) {
      return -1;
    }
    if (i < n - 1) {
      if (fprintf(f, ", ") < 0) {
        return -1;
      }
    }
  }
  if (fprintf(f, "]") < 0) {
    return -1;
  }
  return 0;
}
int table_manager_array_line_int(FILE * f, int * x, int n){
  fprintf(f, "[");
  for (int i=0; i < n; ++i) {
    if (fprintf(f, "%d", x[i]) < 0) {
      return -1;
    }
    if (i < n - 1) {
      if (fprintf(f, ", ") < 0) {
        return -1;
      }
    }
  }
  if (fprintf(f, "]") < 0) {
    return -1;
  }
  return 0;
}
int table_manager_array_double(FILE * f, double * x, int m, int n){
  fprintf(f, "[");
  for (int i=0; i < m; ++i) {
    if (table_manager_array_line_double(f, &x[i*n], n) < 0) {
      return -1;
    }
    if (i < m - 1) {
      if (fprintf(f, ", ") < 0) {
        return -1;
      }
    }
  }
  if (fprintf(f, "]") < 0) {
    return -1;
  }
  return 0;
}
int table_manager_array_int(FILE * f, int * x, int m, int n){
  fprintf(f, "[");
  for (int i=0; i < m; ++i) {
    if (table_manager_array_line_int(f, &x[i*n], n) < 0) {
      return -1;
    }
    if (i < m - 1) {
      if (fprintf(f, ", ") < 0) {
        return -1;
      }
    }
  }
  if (fprintf(f, "]") < 0) {
    return -1;
  }
  return 0;
}

%}

USERVARS
%{
  /* Per-particle dynamic array of recorded times and its allocated size.
   * These fields are inserted into every neutron ray's state struct.
   * NOTE: the generated C code appends an instance-index suffix, e.g. tof_t_5.
   *       TableManager's INITIALIZE locates those fields by name and stores
   *       their byte offsets so that TableSetup and TableRecorder can use
   *       the _TOF_T_PTR / _TOF_N_PTR macros to access the same storage. */
  double * tof_t;
  double * tof_p;
  double * tof_d;
  int tof_n;
%}

DECLARE
%{
  double * table_tp;
  double * table_p;
  double * table_p2;
  int * table_n;
  double * table_d;

  int     _table_n_recorders;
  char * real_filename;

  int n_bins;
  char * t_name;
  char * p_name;
  char * d_name;
  char * n_name;
%}

INITIALIZE
%{
  if (t_bins < 0) {
    fprintf(stderr, "TableManager ERROR: t_bins must be non-negative.\n");
    exit(1);
  }
  if (t_bins > 0 && t_max <= t_min) {
    fprintf(stderr, "TableManager ERROR: t_max must be greater than t_min when t_bins is positive.\n");
    exit(1);
  }
  n_bins = t_bins ? t_bins : 1;

  int name_len = strlen("tof_t_") + log10(1+INDEX_CURRENT_COMP) + 2;
  t_name = calloc(name_len, sizeof(char));
  p_name = calloc(name_len, sizeof(char));
  d_name = calloc(name_len, sizeof(char));
  n_name = calloc(name_len, sizeof(char));
  sprintf(t_name, "tof_t_%ld", INDEX_CURRENT_COMP);
  sprintf(p_name, "tof_p_%ld", INDEX_CURRENT_COMP);
  sprintf(d_name, "tof_d_%ld", INDEX_CURRENT_COMP);
  sprintf(n_name, "tof_n_%ld", INDEX_CURRENT_COMP);


  if (filename && strcmp(filename, "")) {
    real_filename = filename;
  } else {
    real_filename = (char *)calloc(strlen(NAME_CURRENT_COMP) + 14, sizeof(char)); /* "_tof_table.dat" + null terminator */
    sprintf(real_filename, "%s_tof_table.dat", NAME_CURRENT_COMP);
  }



  _table_n_recorders = _tof_recorder_count;

  if (_table_n_recorders <= 0) {
    fprintf(stderr,
      "TableManager WARNING: No TableRecorder components found "
      "(or none were initialised before TableManager).\n");
    table_p = NULL;
    table_p2 = NULL;
    table_n = NULL;
    table_tp = NULL;
    table_d = NULL;
  } else {
    /* Allocate: n_recorders by n_bins (weights) */
    table_p = (double*)calloc((long)n_bins * _table_n_recorders, sizeof(double));
    table_p2 = (double*)calloc((long)n_bins * _table_n_recorders, sizeof(double));
    table_n = (int*)calloc((long)n_bins * _table_n_recorders, sizeof(int));
    table_d = (double*)calloc((long)_table_n_recorders, sizeof(double));
    table_tp = (double*)calloc((long)_table_n_recorders, sizeof(double));
    if (!table_p || !table_p2 || !table_n || !table_d || !table_tp) {
      fprintf(stderr, "TableManager ERROR: Failed to allocate output table.\n");
      free(table_p);
      free(table_p2);
      free(table_n);
      free(table_d);
      free(table_tp);
      exit(1);
    }
  }
%}

TRACE
%{
  double ** tof_t = (double **) particle_getvar_void(_particle, t_name, 0x0);
  double ** tof_p = (double **) particle_getvar_void(_particle, p_name, 0x0);
  double ** tof_d = (double **) particle_getvar_void(_particle, d_name, 0x0);
  int * tof_n = (int *) particle_getvar_void(_particle, n_name, 0x0);
  if (tof_t && tof_p && tof_d && tof_n && *tof_n > 0) {
    #pragma omp critical
    {
      for (int i=0; i < *tof_n; ++i){
        if ((*tof_t)[i] >= t_min && (*tof_t)[i] < t_max) {
          int bin = (int)(((*tof_t)[i] - t_min) / (t_max - t_min) * n_bins);
          if (bin >= 0 && bin < n_bins) {
            int index = bin + i * n_bins;
            table_p[index] += (*tof_p)[i];
            table_p2[index] += (*tof_p)[i] * (*tof_p)[i];
            table_tp[i] += (*tof_t)[i] * (*tof_p)[i];
            table_n[index] += 1;
          }
        }
        table_d[i] = (*tof_d)[i];
      }
    }
    /* Deallocate per-particle array and reset counter.
     * Use tof_n > 0 as the guard: tof_n is zero-initialised
     * by particle_uservar_init so a non-zero value guarantees TableSetup ran
     * and that tof_t is either NULL (calloc failed â†’ already ABSORBed) or a
     * valid pointer. */
    if (*tof_n > 0) {
      if (tof_t) {
        free(*tof_t);
        *tof_t = NULL;
      }
      if (tof_p) {
        free(*tof_p);
        *tof_p = NULL;
      }
      if (tof_d) {
        free(*tof_d);
        *tof_d = NULL;
      }
    *tof_n = 0;
    }
  }
%}

SAVE
%{
  if (table_p && table_p2 && table_n && write_file) {
    FILE* _f = fopen(real_filename, "w");
    if (_f) {
      fprintf(_f, "{\"note\": \"Time-of-flight table generated by component '%s'\",\n", NAME_CURRENT_COMP);
      fprintf(_f, "\"distances\": ");
      table_manager_array_line_double(_f, table_d, _table_n_recorders);
      fprintf(_f, ",\n");

      fprintf(_f, "\"t\": {\"min\": %.15g, \"max\": %.15g, \"bins\": %d},\n", t_min, t_max, n_bins);
      fprintf(_f, "\"tp\": ");
      table_manager_array_double(_f, table_tp, _table_n_recorders, n_bins);
      fprintf(_f, ",\n");
      fprintf(_f, "\"p\": ");
      table_manager_array_double(_f, table_p, _table_n_recorders, n_bins);
      fprintf(_f, ",\n");
      fprintf(_f, "\"p2\": ");
      table_manager_array_double(_f, table_p2, _table_n_recorders, n_bins);
      fprintf(_f, ",\n");
      fprintf(_f, "\"n\": ");
      table_manager_array_int(_f, table_n, _table_n_recorders, n_bins);
      fprintf(_f, "}\n");

      fclose(_f);
    } else {
      fprintf(stderr, "TableManager WARNING: Could not open '%s' for writing.\n", filename);
    }
  }
%}

FINALLY
%{
  if (table_p) {
    free(table_p);
    table_p = NULL;
  }
  if (table_p2) {
    free(table_p2);
    table_p2 = NULL;
  }
  if (table_n) {
    free(table_n);
    table_n = NULL;
  }
  if (table_d) {
    free(table_d);
    table_d = NULL;
  }
  if (real_filename && real_filename != filename) {
    free(real_filename);
    real_filename = NULL;
  }
%}

END
